{
  "version": 3,
  "sources": ["../../vuetify/src/composables/rounded.ts", "../../vuetify/src/composables/location.ts", "../../vuetify/src/composables/color.ts"],
  "sourcesContent": ["// Utilities\nimport { computed, isRef } from 'vue'\nimport { getCurrentInstanceName, propsFactory } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\ntype RoundedValue = boolean | string | number | null | undefined\n\nexport interface RoundedProps {\n  rounded?: RoundedValue\n  tile?: boolean\n}\n\ntype RoundedData = {\n  roundedClasses: Ref<string[]>\n}\n\n// Composables\nexport const makeRoundedProps = propsFactory({\n  rounded: {\n    type: [Boolean, Number, String],\n    default: undefined,\n  },\n}, 'rounded')\n\nexport function useRounded (\n  props: RoundedProps | Ref<RoundedValue>,\n  name = getCurrentInstanceName(),\n): RoundedData {\n  const roundedClasses = computed(() => {\n    const rounded = isRef(props) ? props.value : props.rounded\n    const classes: string[] = []\n\n    if (rounded === true || rounded === '') {\n      classes.push(`${name}--rounded`)\n    } else if (\n      typeof rounded === 'string' ||\n      rounded === 0\n    ) {\n      for (const value of String(rounded).split(' ')) {\n        classes.push(`rounded-${value}`)\n      }\n    }\n\n    return classes\n  })\n\n  return { roundedClasses }\n}\n", "// Composables\nimport { useRtl } from '@/composables/locale'\n\n// Utilities\nimport { computed } from 'vue'\nimport { parseAnchor, propsFactory } from '@/util'\n\n// Types\nimport type { CSSProperties, PropType } from 'vue'\nimport type { Anchor } from '@/util'\n\nconst oppositeMap = {\n  center: 'center',\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left',\n} as const\n\nexport interface LocationProps {\n  location: Anchor | undefined\n}\n\nexport const makeLocationProps = propsFactory({\n  location: String as PropType<Anchor>,\n}, 'location')\n\nexport function useLocation (props: LocationProps, opposite = false, offset?: (side: string) => number) {\n  const { isRtl } = useRtl()\n\n  const locationStyles = computed(() => {\n    if (!props.location) return {}\n\n    const { side, align } = parseAnchor(\n      props.location.split(' ').length > 1\n        ? props.location\n        : `${props.location} center` as Anchor,\n      isRtl.value\n    )\n\n    function getOffset (side: string) {\n      return offset\n        ? offset(side)\n        : 0\n    }\n\n    const styles = {} as CSSProperties\n\n    if (side !== 'center') {\n      if (opposite) styles[oppositeMap[side]] = `calc(100% - ${getOffset(side)}px)`\n      else styles[side] = 0\n    }\n    if (align !== 'center') {\n      if (opposite) styles[oppositeMap[align]] = `calc(100% - ${getOffset(align)}px)`\n      else styles[align] = 0\n    } else {\n      if (side === 'center') styles.top = styles.left = '50%'\n      else {\n        styles[({\n          top: 'left',\n          bottom: 'left',\n          left: 'top',\n          right: 'top',\n        } as const)[side]] = '50%'\n      }\n      styles.transform = {\n        top: 'translateX(-50%)',\n        bottom: 'translateX(-50%)',\n        left: 'translateY(-50%)',\n        right: 'translateY(-50%)',\n        center: 'translate(-50%, -50%)',\n      }[side]\n    }\n\n    return styles\n  })\n\n  return { locationStyles }\n}\n", "// Utilities\nimport { computed, isRef } from 'vue'\nimport { destructComputed, getForeground, isCssColor } from '@/util'\n\n// Types\nimport type { CSSProperties, Ref } from 'vue'\n\ntype ColorValue = string | false | null | undefined\n\nexport interface TextColorData {\n  textColorClasses: Ref<string[]>\n  textColorStyles: Ref<CSSProperties>\n}\n\nexport interface BackgroundColorData {\n  backgroundColorClasses: Ref<string[]>\n  backgroundColorStyles: Ref<CSSProperties>\n}\n\n// Composables\nexport function useColor (colors: Ref<{ background?: ColorValue, text?: ColorValue }>) {\n  return destructComputed(() => {\n    const classes: string[] = []\n    const styles: CSSProperties = {}\n\n    if (colors.value.background) {\n      if (isCssColor(colors.value.background)) {\n        styles.backgroundColor = colors.value.background\n\n        if (!colors.value.text) {\n          const textColor = getForeground(styles.backgroundColor)\n\n          styles.color = textColor\n          styles.caretColor = textColor\n        }\n      } else {\n        classes.push(`bg-${colors.value.background}`)\n      }\n    }\n\n    if (colors.value.text) {\n      if (isCssColor(colors.value.text)) {\n        styles.color = colors.value.text\n        styles.caretColor = colors.value.text\n      } else {\n        classes.push(`text-${colors.value.text}`)\n      }\n    }\n\n    return { colorClasses: classes, colorStyles: styles }\n  })\n}\n\nexport function useTextColor (color: Ref<ColorValue>): TextColorData\nexport function useTextColor <T extends Record<K, ColorValue>, K extends string> (props: T, name: K): TextColorData\nexport function useTextColor <T extends Record<K, ColorValue>, K extends string> (\n  props: T | Ref<ColorValue>,\n  name?: K\n): TextColorData {\n  const colors = computed(() => ({\n    text: isRef(props) ? props.value : (name ? props[name] : null),\n  }))\n\n  const {\n    colorClasses: textColorClasses,\n    colorStyles: textColorStyles,\n  } = useColor(colors)\n\n  return { textColorClasses, textColorStyles }\n}\n\nexport function useBackgroundColor (color: Ref<ColorValue>): BackgroundColorData\nexport function useBackgroundColor <T extends Record<K, ColorValue>, K extends string> (props: T, name: K): BackgroundColorData\nexport function useBackgroundColor <T extends Record<K, ColorValue>, K extends string> (\n  props: T | Ref<ColorValue>,\n  name?: K\n): BackgroundColorData {\n  const colors = computed(() => ({\n    background: isRef(props) ? props.value : (name ? props[name] : null),\n  }))\n\n  const {\n    colorClasses: backgroundColorClasses,\n    colorStyles: backgroundColorStyles,\n  } = useColor(colors)\n\n  return { backgroundColorClasses, backgroundColorStyles }\n}\n"],
  "mappings": "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",
  "names": ["makeRoundedProps", "propsFactory", "rounded", "type", "Boolean", "Number", "String", "default", "undefined", "useRounded", "props", "name", "arguments", "length", "getCurrentInstanceName", "roundedClasses", "computed", "isRef", "value", "classes", "push", "split", "oppositeMap", "center", "top", "bottom", "left", "right", "makeLocationProps", "propsFactory", "location", "String", "useLocation", "props", "opposite", "arguments", "length", "undefined", "offset", "isRtl", "useRtl", "locationStyles", "computed", "side", "align", "parseAnchor", "split", "value", "getOffset", "styles", "transform", "useColor", "colors", "destructComputed", "classes", "styles", "value", "background", "isCssColor", "backgroundColor", "text", "textColor", "getForeground", "color", "caretColor", "push", "colorClasses", "colorStyles", "useTextColor", "props", "name", "computed", "isRef", "textColorClasses", "textColorStyles", "useBackgroundColor", "backgroundColorClasses", "backgroundColorStyles"]
}
